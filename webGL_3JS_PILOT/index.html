<!doctype html>
<html lang="en">
<head>
  <title>Treehouse Logo in three.js</title>
  <meta charset="utf-8">
</head>
<body style="margin: 0;">

  <script src="js/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>

  <script>

    // Set up the scene, camera, and renderer as global variables.
    var scene, camera, renderer;

    init();
    animate();

    // Sets up the scene.
    function init() {

      // Create the scene and set the scene size.
      scene = new THREE.Scene();
      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;

      // Create a renderer and add it to the DOM.
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(WIDTH, HEIGHT);
      document.body.appendChild(renderer.domElement);

      // Create a camera, zoom it out from the model a bit, and add it to the scene.
      camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 10000);
      camera.position.set( 50, 50, 50 );
	  
		scene.add(camera);
	  
      // Create an event listener that resizes the renderer with the browser window.
      window.addEventListener('resize', function() {
        var WIDTH = window.innerWidth,
            HEIGHT = window.innerHeight;
        renderer.setSize(WIDTH, HEIGHT);
        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();
      });
	  document.addEventListener( 'mousedown', onDocumentMouseDown, false );

	var projector = new THREE.Projector();

	function onDocumentMouseDown( event ) {

		event.preventDefault();

		var vector = new THREE.Vector3(
			( event.clientX / window.innerWidth ) * 2 - 1,
		  - ( event.clientY / window.innerHeight ) * 2 + 1,
			0.5
		);
		projector.unprojectVector( vector, camera );

		var ray = new THREE.Ray( camera.position, 
								 vector.subSelf( camera.position ).normalize() );

		var intersects = ray.intersectObjects( objects );

		if ( intersects.length > 0 ) {

			intersects[ 0 ].object.materials[ 0 ].color.setHex( Math.random() * 0xffffff );

			var particle = new THREE.Particle( particleMaterial );
			particle.position = intersects[ 0 ].point;
			particle.scale.x = particle.scale.y = 8;
			scene.add( particle );

		}
		
		for ( var i in intersects ) {
        intersects[ i ].face.material[ 0 ].color
            .setHex( Math.random() * 0xffffff | 0x80000000 );
		}
	}


      // Set the background color of the scene.
      renderer.setClearColorHex(0x333F47, 1);

      // Create a light, set its position, and add it to the scene.
      var light = new THREE.PointLight(0xffffff);
      light.position.set(100,100,250);
      scene.add(light);

	  //var geometry = new THREE.SphereGeometry( 1, 32, 32 );
		//var material = new THREE.MeshBasicMaterial(  {color: 0x0033ff, specular: 0x555555, shininess: 50} );
		//var sphere = new THREE.Mesh( geometry, material );
		//scene.add( sphere );
	

	group = new THREE.Object3D();
	
		var bitmap = new Image();
		bitmap.src = 'models/white.jpg'
    var texture = THREE.ImageUtils.loadTexture(bitmap.src); // Create texture object based on the given bitmap path.
    var material = new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0x050505, shininess: 50, map: texture }); // Create a material (for the spherical mesh) that reflects light, potentially causing sphere surface shadows.
    var geometry = new THREE.SphereGeometry(1, 64, 64); // Radius size, number of vertical segments, number of horizontal rings.
	var sphere = new THREE.Mesh(geometry, material); // Create a mesh based on the specified geometry (cube) and material (blue skin).
    //scene.add(sphere); 
	//sphere.position.set(0.702825, 2.71217, 2.71612);
	
	fetch('Une_image_256_atomes.txt').then(response => response.text()).then(text => {
	  const atoms = text.split('\n')  // split into lines
		.map(line => line.trim())     // remove whitespace at the beginning and end
		.map(line => line.split(' ')) // split by ' '
		.map(([size, x, y, z]) => ({ 
		  size: Number(size), 
		  x: Number(x), 
		  y: Number(y), 
		  z: Number(z) 
		}));
		
		for (var i = 0; i < atoms.length; i++) {
		
			instance = sphere.clone();
			instance.position.set( atoms[i].x, atoms[i].y, atoms[i].z );
			group.add( instance );
				
		}
		
		pivot = new THREE.Object3D();
		pivot.add( group );
		scene.add( pivot );

		scene.add(group);
	
	});
	
	//make the image even on the sphere
		var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
		for ( i = 0; i < faceVertexUvs.length; i ++ ) {

			var uvs = faceVertexUvs[ i ];
			var face = geometry.faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				uvs[ j ].x = face.vertexNormals[ j ].x * 0.5 + 0.5;
				uvs[ j ].y = face.vertexNormals[ j ].y * 0.5 + 0.5;

			}

		}

      // Add OrbitControls so that we can pan around with the mouse.
      controls = new THREE.OrbitControls(camera, renderer.domElement);

    }


    // Renders the scene and updates the render as needed.
    function animate() {

      // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
      requestAnimationFrame(animate);
      
      // Render the scene.
      renderer.render(scene, camera);
      controls.update();
	  pivot.rotation.y += 0.015;

    }

  </script>

</body>
</html>
